# -*- coding: utf-8 -*-
"""ProssimoTech_project_june14.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yy4I8q3UX9Cj-Jk1rHxL8cn8rogMnqj_
"""

# Commented out IPython magic to ensure Python compatibility.
#@title *import packages & mtfa implementation*
#  %%capture
import numpy as np
import pywt
import os, random
import pandas as pd
import datetime as datetime
import matplotlib.pyplot as plt
import matplotlib.ticker as mtick
from google.colab import files
from scipy.sparse.linalg import eigsh
from scipy.linalg import eigh
from numpy.linalg import norm, matrix_rank

def shrink_eig(X, tau):
    d, v = eigsh(X, k = min(5, X.shape[0]), which="LM")
    if d[0]<= tau:
      return np.dot(v*np.maximum(d-tau,0), v.T)
    else:
      return np.dot(v*np.maximum(d-tau,0), v.T)+shrink_eig(X-np.dot(v*d, v.T), tau)

def objective_func(O, A, tau):
    D = np.diag(np.maximum(np.diag(O-A), 0))
    return norm(A, 'nuc')*tau + 1/2*norm(O-A-D)**2

def func_A(O, A, tau):
    X = O-np.diag(np.maximum(np.diag(O-A),0))
    return shrink_eig(X, tau)

def fix_pt_iteration(k, O, A, tau):
    print(objective_func(O, A, tau))
    for i in range(k):
        A = func_A(O, A, tau)
        print(objective_func(O, A, tau))
    return A

def fp2(O, A, tau, epsilon = 1e-12,max_iter = 5000):
    a = np.inf,
    for _ in range(max_iter):
        A = func_A(O, A, tau)
        b = objective_func(O, A, tau)
        if(abs(a-b)<epsilon): break
        a = b
    return A

def match_rank0(O,A, tau_range, r=1,max_iter = 100, steps = 10000, epsilon = 1e-8, smallest = True):
    # r: target rank
    # O: sample covariance
    tau = (tau_range[0]+tau_range[1])/2
    A = fp2(O, A, tau, epsilon, max_iter)
    mr = matrix_rank(A)
    for _ in range(steps):
      if mr == r: break
      tau_range[1*(mr<r)] = tau
      tau = (tau_range[0]+tau_range[1])/2
      A = fp2(O, A, tau, epsilon, max_iter)    
      mr = matrix_rank(A)
    out_tau = tau_range.copy()
    if mr == r:
      index = 1- smallest
      tau_range[index] = tau
      mtau = tau
      for tau in np.geomspace(tau_range[index], tau_range[1-index], num = 50):
        A = fp2(O, A, tau, epsilon, max_iter)
        if matrix_rank(A) != r: 
          break
        mtau = tau 
      A = fp2(O, A, mtau, epsilon, max_iter)
      tau_range[index] = mtau
    return A, tau_range, (mr == r)


def ls_minvar(B, V_inv, svar):
    M = B.T / svar
    A = V_inv + M @ B
    b = np.sum(M, 1)
    theta = np.linalg.solve(A,b)
    w = (1.0 - B @ theta) / svar
    return w/np.sum(w)

def getA(L):
    vals, vecs = eigsh(L, 1, which = "LA")
    return vecs.dot(np.diag(vals).dot(vecs.T))
    
def getD(A, O):
    return np.diag(np.maximum(np.diag(O-A), 0))


from rpy2.robjects import r
from rpy2.robjects.packages import importr
import rpy2.robjects.numpy2ri
rpy2.robjects.numpy2ri.activate()
utils = importr('utils')
utils.install_packages('glasso')

pd.options.display.float_format = '{:,.4f}'.format

#@title *read data*
def r2S(r, cor = False, centered = True):
  Y = r.to_numpy()
  Z = Y - centered * np.ones((Y.shape[0], 1)) @ Y.mean(axis = 0).reshape(1, Y.shape[1])
  S = Z.T @ Z / Z.shape[0]
  if not cor: return S
  else:
    d = np.diag(1/np.sqrt(np.diag(S)))
    return d @ S @ d

def cov2cor(S):
    dimen = S.shape
    n = max(dimen)
    R = np.zeros((n,n))
    for i in range(n):
        for j in range(n):
            R[i,j] = S[i,j]/np.sqrt(S[i,i]*S[j,j])
        
    return R

def fd(fig, name = 'fig.png', dpi='figure'):
  fig.savefig(name, dpi=dpi, bbox_inches='tight')
  files.download(name)
  pass

p2r = lambda df: (df.shift(periods = -1)/df -1).head(-1)
p2logr = lambda df: (np.log(df).shift(periods = -1) - np.log(df)).head(-1)
p = lambda df: print(df.to_string()+'\n')

# file path dictionary
d = {0: 'drive/MyDrive/ProssimoTech/index05312021.csv', 
     1: 'drive/MyDrive/ProssimoTech/index_bloomberg.csv',
     2: 'drive/MyDrive/ProssimoTech/Index_en.csv',
     3: 'drive/MyDrive/ProssimoTech/index_0511_all.csv'}
filepath = d[0]

daily = pd.read_csv(filepath)
daily.Date = pd.to_datetime(daily.Date)
start, end = daily.Date.iat[0].year,  daily.Date.iat[-1].year
daily = daily.set_index('Date')

daily = daily.dropna(axis = 'columns')
# remove columns
f, columns = False, []
for c in daily.columns:
  if c.startswith('Unnamed') or f:
    f = True
    columns.append(c)
  
#daily = daily.drop(columns = columns)

weekly = daily.loc[daily.index.weekday == 2]

# monthly price
l = [weekly.index[0]]
for d in weekly.index:
  if l[-1].month != d.month:
    l.append(d)
monthly = weekly.loc[pd.DatetimeIndex(l)]

weekly_r = p2r(weekly)
df = weekly_r
print('weekly regular return summary')
p(weekly_r.describe())


#@title *plot cov*
def plot_cov(df, centered = centered, title ='fig.png'):
  years = range(start, end+1)
  fig, ax = plt.subplots(len(years), 3, figsize = (12, 6*len(years)))
  for j, year in enumerate(years):
    df_ = df[df.index.year == year].dropna(axis = 'columns')
    S = r2S(df_, cor = False, centered = centered) # sample cov
    R = cov2cor(S) # correlation
    im =ax[j, 0].matshow(S, cmap = 'GnBu')
    ax[j, 0].set_title(f'Sample covariance {year}')
    fig.colorbar(im, ax =ax[j, 0], shrink = 0.8)
    
    im = ax[j, 1].matshow(R, cmap = 'GnBu')
    ax[j, 1].set_title('correlation')
    fig.colorbar(im, ax =ax[j, 1], shrink = 0.8)
    
    P = np.linalg.pinv(S) # precision by pseudo inverse
    im = ax[j, 2].matshow(P, cmap = 'GnBu')
    ax[j, 2].set_title('precision')
    fig.colorbar(im, ax= ax[j, 2], shrink = 0.8)
  #plt.show()
  fd(fig, name = title)
  #fig.savefig(title, transparent=False)
  pass



t1 = ['log-return', 'reg-return']
t2 = ['daily', 'weekly', 'monthly']
t3 = ['centered', 'noncentered']
for i, log_return in enumerate([False, True]):
  for j, p in enumerate([daily, weekly, monthly]):
    r = p2logr(p) if log_return else p2r(p) 
    for k, centered in enumerate([False, True]):
      fname = t1[i] + '-' + t2[j] + '-' + t3[k] + '.png' 
      plot_cov(df = r, centered = centered, title = fname)
      
     
#print('cov')
#plot_cov(df = False)

#@title *eigenvalue plots*
def plot_pc(df, centered = True, title ='fig.png'):
  df = df.dropna(axis = 'columns')
  years = range(start, end+1)
  fig = plt.figure(figsize=(16, 40))
  subtitle = ['eigenvalue (cov)', 'variance explained (cov)', 'eigenvalue (cor)', 'correlation explained (cor)', 'eigen portofio variance (cor)', 'variance explained (cor)']
  xlabs = [str(y) if y%5 == 0 else '' for y in years]
  res = [[] for _ in range(len(title))]
  p = df.shape[1]
  for j, year in enumerate(years):
    df_ = df[df.index.year == year].dropna(axis = 'columns')
    S = r2S(df_, cor = False, centered = centered) # sample cov
    R = cov2cor(S) # correlation
    for i, S_ in enumerate([S, R]):
      vals, vecs = eigh (S_)
      rev_vals = vals[::-1]
      res[2*i].extend([list(rev_vals)])
      res[2*i+1].extend([list(rev_vals/np.trace(S))])
    e = [v @ S @ v.T for v in vecs.T]
    rev_e = e[::-1]
    res[4].extend([list(rev_e)])
    res[5].extend([list(rev_e/np.trace(S))])

  for i in range(len(subtitle)):
    plt.subplot((len(title)+len(title)%2)//2, 2, i+1)
    plt.title(subtitle[i])
    v = np.reshape(res[i], (len(years), p))
    plt.plot(years, v)
  plt.show()
  fd(fig, name = title)
  #fig.savefig(title, transparent=False, bbox_inches='tight')
  #files.download(title)
  pass